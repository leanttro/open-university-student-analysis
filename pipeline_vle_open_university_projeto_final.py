# -*- coding: utf-8 -*-
"""Pipeline VLE - Open University (PROJETO FINAL)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PlLEMSQORYXghT9JbP4IMlL8UX3Ih-Lu

### ***• INSTALAÇÃO DE PACOTES:***
"""

!pip install scikit-learn
import pandas as pd
from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
!pip install SQLAlchemy
import pandas as pd
import sqlite3
from sqlalchemy import create_engine
pd.set_option('display.float_format', '{:,.2f}'.format)
sns.set_theme(style="whitegrid")

"""**-  Pacotes utilizados: scikit-learn, pandas, seaborn. matplotlib, numpy, SQLAlchemy, sqlite3.**

### ***• CARREGAMENTO DE PLANILHAS:***
"""

studentAssessment = pd.read_csv("studentAssessment.csv")
studentInfo = pd.read_csv("studentInfo.csv")
studentRegistration = pd.read_csv("studentRegistration.csv")
studentVle = pd.read_csv("studentVle.csv")

"""Planilhas utilizadas: studentAssessment,  studentInfo,  studentRegistration, studentVle.

### ***• VISUALIZAÇÃO DE PLANILHAS:***
"""

studentInfo

studentVle

studentRegistration

studentAssessment

"""### ***• ARMAZENAMENTO DE DADOS CRUS (BRONZE):***"""

engine = create_engine("sqlite:///lakehouse.db")

studentInfo.to_sql("studentInfo_bronze", engine, if_exists="replace", index=False)
studentVle.to_sql("studentVle_bronze", engine, if_exists="replace", index=False)
studentRegistration.to_sql("studentRegistration_bronze", engine, if_exists="replace", index=False)
studentAssessment.to_sql("studentAssessment_bronze", engine, if_exists="replace", index=False)

"""### ***• LIMPEZA DE DADOS:***"""

studentInfo = studentInfo.dropna().drop_duplicates(subset='id_student')
studentVle = studentVle.dropna()
studentRegistration = studentRegistration.dropna()
studentAssessment = studentAssessment.dropna()

"""### ***• ARMAZENAMENTO DE DADOS LIMPOS (PRATA):***"""

studentInfo.to_sql("studentInfo_silver", engine, if_exists="replace", index=False)
studentVle.to_sql("studentVle_silver", engine, if_exists="replace", index=False)
studentRegistration.to_sql("studentRegistration_silver", engine, if_exists="replace", index=False)
studentAssessment.to_sql("studentAssessment_silver", engine, if_exists="replace", index=False)

"""### ***CRIAÇÃO DA MATRIZ DOS CLIQUES (CLICK_MATRIX) :***"""

click_matrix = studentVle.pivot_table(
    index="id_student",
    columns="id_site",
    values="sum_click",
    aggfunc="sum",
    fill_value=0)

"""### ***• VALIDAÇÃO DE IDS:***"""

valid_ids = click_matrix.index.intersection(studentInfo['id_student'].unique())
click_matrix = click_matrix.loc[valid_ids]
studentInfo_filtered = studentInfo.set_index('id_student').loc[valid_ids]

"""### ***• CRIAÇÃO DO TENSOR UTILIZANDO NUMPY :***"""

tensor = click_matrix.to_numpy()
df_tensor = pd.DataFrame(tensor, index=click_matrix.index, columns=click_matrix.columns)
df_tensor['final_result'] = studentInfo_filtered['final_result']

"""***•  ANÁLISE EXPLORATÓRIA DE DADOS:***
---

### **- TOTAL DE ALUNOS**

- Visão Geral dos Dados Numéricos
- Distruibuição do Resultado Final  
- Participação Total por Região  
- Alunos em Regiões com Pobreza Superior a 50% (por País)  
- Total de Alunos com Deficiência (PCD)  
- Interações com o Ambiente Virtual de Aprendizagem (VLE) por Ano  
- Total de Alunos que Desistiram  

---
***• ESCOLHA ENTRE*** :
---



### **- APROVADOS**

- Visão Geral dos Aprovados    
- Distribuição por Gênero  
- Distribuição por Região  
- Aprovados em Regiões com Pobreza Superior a 50%  
- Aprovações na Primeira Tentativa

### **- REPROVADOS**

- Visão Geral dos Reprovados    
- Distribuição por Gênero  
- Distribuição por Região  
- Reprovados em Regiões com Pobreza Superior a 50%  
- Reprovações na Primeira Tentativa  

---

### **- CLIQUES**
- Relação de Alunos x Cliques
- Média de Clique Semanal por Total de Alunos
- Distruibuição de Cliques na Semana da Avaliação
- Soma Total de Cliques de Alunos por Semana


***•  MACHINE LEARNING:***
- Modelo de ML com RandomForest para prever sucesso (Pass/Distinction) vs não-sucesso (Fail/Withdraw).

.

.

.

---
###                 ***• TOTAL DE ALUNOS***
---

### - Visão Geral dos Dados Numéricos
"""

studentInfo.describe()

"""### -  Distribuição por Resultado Final"""

studentInfo.groupby("final_result")["final_result"].value_counts().sort_values(ascending=False)

plt.figure(figsize=(6,6))
df_tensor['final_result'].value_counts().plot.pie(autopct='%1.1f%%', startangle=90, colors=sns.color_palette('Set2'))
plt.title('Distribuição dos Resultados Finais')
plt.ylabel('')
plt.show()

"""### -  Participação Total por Região  """

studentInfo.groupby("region")["region"].value_counts().sort_values(ascending=False)

plt.figure(figsize=(6,4))

sns.countplot(
data = studentInfo,
y = "region",
order = studentInfo["region"].value_counts().index,palette = "Greens_d"),
color="crimson"
plt.title("Participação Total por Região ")
plt.xlabel("Total de Alunos")
plt.ylabel("Região")
plt.show()

"""### - Alunos em Regiões com Pobreza Superior a 50% (por País)  """

studentInfo["imd_band"].unique()

maior50 = ['50-60%','50-60%','60-70%','70-80%','80-90%','90-100%']
studentamaior50= studentInfo[studentInfo["imd_band"].isin(maior50)]
studentamaior50["id_student"].count()

studentamaior50.groupby("region")["region"].value_counts().sort_values(ascending=False)

plt.figure(figsize=(6,4))

sns.countplot(
data = studentamaior50,
y = "region",
order = studentInfo["region"].value_counts().index,palette = "Greens_d"),
color="crimson"
plt.title("Alunos em Regiões com Pobreza Superior a 50% (por País)")
plt.xlabel("Total de Alunos")
plt.ylabel("Região")
plt.show()

"""### - Total de Alunos com Deficiência (PCD)"""

studentInfo[studentInfo["disability"] == "Y"].describe()

plt.figure(figsize=(6,4))
sns.barplot(
data = studentInfo,
x = "disability",
y = "id_student",
color="crimson",
estimator = len)
plt.title("Total de Alunos com Deficiência")
plt.xlabel("Possui Deficiência")
plt.ylabel("Total de Alunos")Q
plt.show()

"""### Interações com o Ambiente Virtual de Aprendizagem (VLE) por Ano"""

studentVle["code_presentation"].unique()

studentVle.groupby("code_presentation")["sum_click"].count()

df_year = studentVle.groupby("code_presentation")["sum_click"].count().reset_index()

plt.figure(figsize=(6, 4))
sns.lineplot(
    data=df_year,
    x="code_presentation",
    y="sum_click",
    marker="o",
    color="crimson"
)

plt.title("Interações com o Ambiente Virtual de Aprendizagem (VLE) por Ano ")
plt.xlabel("Semestre")
plt.ylabel("Total de Interações com o VLE")
plt.show()

"""### - Total de Alunos que Desistiram  """

studentInfo["final_result"].unique()

studentInfo.groupby("final_result")["final_result"].value_counts().sort_values(ascending=False)

studentInfo[studentInfo["final_result"] == "Withdrawn"].describe()

plt.figure(figsize=(6,4))
sns.barplot(
data = studentInfo,
x = "final_result",
y = "id_student",
color="crimson",
estimator = len)
plt.title("Total de Alunos com Deficiência")
plt.xlabel("Possui Deficiência")
plt.ylabel("Total de Alunos")
plt.show()

"""---
### ***• ESCOLHA PARA ANALISAR ENTRE OS ALUNOS:***
*   APROVADOS (Pass e Distinction)
*   REPROVADOS (Faill e Withdrawn)

---
"""

aprovados = studentInfo[(studentInfo["final_result"] == "Pass") | (studentInfo["final_result"] == "Distinction")]
reprovados = studentInfo[(studentInfo["final_result"] == "Fail") | (studentInfo["final_result"] == "Withdrawn")]
x = input("DIGITE 'APROVADOS' OU 'REPROVADOS': ").lower().strip()
if x == "aprovados":
  x = aprovados
elif x == "reprovados":
  x = reprovados
else:
  print("ERRO! Digite [APROVADOS] ou [REPROVADOS]")

"""### - Visão Geral dos Dados Numéricos **(APROVADOS ou REPROVADOS)**  """

plt.figure(figsize=(6,4))
sns.barplot(
data = x,
x = "final_result",
y = "id_student",
color="crimson",
estimator = len)
plt.title("Aprovados ou Reprovado por seus tipos")
plt.xlabel("Aprovado(Pass/Distinction) | Reprovado(Faill/Withdrawn)")
plt.ylabel("Total de Alunos")
plt.show()

"""*   APROVADOS (Pass e Distinction)
*   REPROVADOS (Faill e Withdrawn)
"""

x.groupby("final_result")["final_result"].value_counts().sort_values(ascending=False)

x.describe()

"""### -  Participação Total de **APROVADOS ou REPROVADOS** por Região"""

x.groupby("region")["region"].value_counts().sort_values(ascending=False)

plt.figure(figsize=(6,4))

sns.countplot(
data = x,
y = "region",
order = x["region"].value_counts().index,palette = "Greens_d"),
color="crimson"
plt.title("Participação Total de APROV. OU REPROV. por Região ")
plt.xlabel("Total de Aprovados ou Reprovados")
plt.ylabel("Região")
plt.show()

"""## **- Distribuição por Gênero**"""

x.groupby("gender")["gender"].value_counts().sort_values(ascending=False)

"""### - Alunos **APROVADOS ou REPROVADOS** em Regiões com Pobreza Superior a 50% (por País)  """

xx50 = ['50-60%','50-60%','60-70%','70-80%','80-90%','90-100%']
x50= x[x["imd_band"].isin(xx50)]
x50["id_student"].count()

x.groupby("region")["region"].value_counts().sort_values(ascending=False)

plt.figure(figsize=(6,4))

sns.countplot(
data = x50,
y = "region",
order = x50["region"].value_counts().index,palette = "Greens_d"),
color="crimson"
plt.title("Alunos APROV. OU REPROV. em Regiões com Pobreza Superior a 50% (por País)")
plt.xlabel("Total de Aprovados")
plt.ylabel("Região")
plt.show()

"""### - Aprovações ou Reprovações na Primeira Tentativa (0)"""

x.groupby("num_of_prev_attempts")["num_of_prev_attempts"].value_counts().sort_values(ascending=False)

plt.figure(figsize=(6,4))
sns.barplot(
data = x,
x = "num_of_prev_attempts",
y = "num_of_prev_attempts",
color="crimson",
estimator = len)
plt.title("Aprovados ou Reprovado por seus tipos")
plt.xlabel("Aprovado(Pass/Distinction) | Reprovado(Faill/Withdrawn)")
plt.ylabel("Total de Alunos")
plt.show()

"""---
###                 ***• CLIQUES***
---

### - Relação de Alunos x Cliques
"""

studentVle_merged = studentVle.merge(studentInfo[['id_student', 'final_result']], on='id_student')
clicks_categoria= studentVle_merged.groupby(['date', 'final_result'])['sum_click'].sum().reset_index()

plt.figure(figsize=(12, 6))
sns.lineplot(data=clicks_categoria, x='date', y='sum_click', hue='final_result', palette='Set2')
plt.title('Total de Cliques por Semana, por Categoria de Resultado')
plt.xlabel('Semana')
plt.ylabel('Total de Cliques')
plt.legend(title='Resultado Final')
plt.grid(True)
plt.tight_layout()
plt.show()

"""## - Média de Clique Semanal por Total de Alunos"""

df_tensor.groupby('final_result').mean()

"""### - Distruibuição de Cliques na Semana da Avaliação"""

semana_50 = studentVle_merged[studentVle_merged['date'] == 0]
sns.boxplot(data=semana_50, x='final_result', y='sum_click', palette='Set3')
plt.title('Distribuição de Cliques na Semana da Avaliação por Categoria')
plt.xlabel('Resultado Final')
plt.ylabel('Cliques')
plt.grid(True)
plt.show()

"""## - Soma Total de Cliques de Alunos por Semana"""

clicks_por_semana = studentVle.groupby('date')['sum_click'].sum().sum()
clicks_por_semana

clicks_por_semana = studentVle.groupby('date')['sum_click'].sum()
plt.figure(figsize=(10, 5))
sns.lineplot(x=clicks_por_semana.index, y=clicks_por_semana.values)
plt.title('Total de Cliques por Semana (Todos os Alunos)')
plt.xlabel('Semana')
plt.ylabel('Total de Cliques')
plt.grid(True)
plt.tight_layout()
plt.show()

"""### ***MACHINE LEARNING***

Modelo de Machine Learningcom RandomForest para prever sucesso (Pass/Distinction) vs não-sucesso
(Fail/Withdraw).
"""

X = df_tensor.drop(columns=['final_result'])
y = df_tensor['final_result'].map(lambda x: 1 if x in ['Pass', 'Distinction'] else 0)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

model_rf = RandomForestClassifier(random_state=42)
model_rf.fit(X_train, y_train)
y_pred_rf = model_rf.predict(X_test)

print("Relatório - Random Forest")
print(classification_report(y_test, y_pred_rf))

cm = confusion_matrix(y_test, y_pred_rf)
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues",
            xticklabels=["Reprovado", "Aprovado"],
            yticklabels=["Reprovado", "Aprovado"])
plt.ylabel("Real")
plt.title("HEATMAP")
plt.show()

"""### ***• Armazenamento de Dados Analíticos no BANCO DE DADOS (OURO):***"""

studentInfo.to_sql("studentInfo_gold", engine, if_exists="replace", index=False)
studentVle.to_sql("studentVle_gold", engine, if_exists="replace", index=False)
studentRegistration.to_sql("studentRegistration_gold", engine, if_exists="replace", index=False)
studentAssessment.to_sql("studentAssessment_gold", engine, if_exists="replace", index=False)

"""### ***INSIGHTS:***

- O número de alunos **aprovados** em regiões com mais de 50% de pobreza é **maior** do que o número de **reprovados** nessas mesmas regiões.  
- O número de **cliques** próximo à avaliação aumenta consideravelmente em todas as categorias de resultado final, mas é **ainda maior entre os alunos aprovados**.  
- Apesar de a **região da Irlanda** ter menos participantes do que a **North Region**, ela apresentou um número maior de aprovados. Vale destacar que também é a região com o **menor índice de pobreza** entre todas.  
- O número de cliques no **segundo semestre** do ano tende a ser maior do que no começo do ano, o que pode ser explicado por cursos que iniciam a partir de **julho**.  
- O número de **alunas aprovadas** é maior do que o de **alunos aprovados**, embora o total de alunos seja maior do que o total de alunas.  
- Entre os alunos que **não tiveram sucesso**, a grande maioria **desistiu** do curso, em vez de ser reprovada por desempenho.  
- **13.232** alunos foram reprovados na primeira tentativa, enquanto **11.932** foram aprovados na primeira tentativa.  
- Como o número de aprovados é maior que o de reprovados, o modelo de **Machine Learning Random Forest** tende a acertar mais os aprovados do que os reprovados. Isso explica por que a **acurácia para aprovados** apresenta um valor mais alto.
"""